#!/usr/bin/env python3
"""
Pronunciation Assessment Tool

ƒê√°nh gi√° chi ti·∫øt ph√°t √¢m t·ª´ v√† c√¢u c·ªßa ng∆∞·ªùi d√πng b·∫±ng c√°ch so s√°nh
c√¢u g·ªëc v·ªõi k·∫øt qu·∫£ Speech-to-Text.

Usage:
    python pronunciation-assessment.py
    
    Or import as module:
    from pronunciation_assessment import assess_pronunciation
"""

import re
import difflib
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass
import eng_to_ipa as ipa

@dataclass
class WordError:
    """L∆∞u th√¥ng tin l·ªói c·ªßa m·ªôt t·ª´"""
    word: str
    expected_ipa: str
    actual_ipa: str
    error_type: str
    ipa_differences: List[str]

class PronunciationAssessment:
    """Class ch√≠nh ƒë·ªÉ ƒë√°nh gi√° ph√°t √¢m"""
    
    def __init__(self):
        self.word_errors = []
    
    def _clean_text(self, text: str) -> str:
        """L√†m s·∫°ch text, lo·∫°i b·ªè d·∫•u c√¢u v√† chu·∫©n h√≥a"""
        # Lo·∫°i b·ªè d·∫•u c√¢u v√† k√Ω t·ª± ƒë·∫∑c bi·ªát
        cleaned = re.sub(r'[^\w\s]', '', text.lower())
        # Chu·∫©n h√≥a kho·∫£ng tr·∫Øng
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        return cleaned
    
    def _get_ipa_pronunciation(self, word: str) -> str:
        """Chuy·ªÉn t·ª´ sang IPA"""
        try:
            return ipa.convert(word)
        except Exception:
            return word  # Fallback n·∫øu kh√¥ng convert ƒë∆∞·ª£c
    
    def _calculate_word_similarity(self, word1: str, word2: str) -> float:
        """T√≠nh ƒë·ªô t∆∞∆°ng ƒë·ªìng gi·ªØa 2 t·ª´"""
        return difflib.SequenceMatcher(None, word1.lower(), word2.lower()).ratio()
    
    def _calculate_ipa_similarity(self, ipa1: str, ipa2: str) -> float:
        """T√≠nh ƒë·ªô t∆∞∆°ng ƒë·ªìng IPA gi·ªØa 2 t·ª´"""
        return difflib.SequenceMatcher(None, ipa1, ipa2).ratio()
    
    def _find_ipa_differences(self, expected_ipa: str, actual_ipa: str) -> List[str]:
        """T√¨m c√°c √¢m IPA kh√°c nhau"""
        differences = []
        matcher = difflib.SequenceMatcher(None, expected_ipa, actual_ipa)
        
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'replace':
                differences.append(f"'{expected_ipa[i1:i2]}' ‚Üí '{actual_ipa[j1:j2]}'")
            elif tag == 'delete':
                differences.append(f"missing '{expected_ipa[i1:i2]}'")
            elif tag == 'insert':
                differences.append(f"extra '{actual_ipa[j1:j2]}'")
        
        return differences
    
    def _advanced_word_matching(self, original_words: List[str], spoken_words: List[str]) -> List[Tuple[int, int, float]]:
        """
        Thu·∫≠t to√°n matching n√¢ng cao ƒë·ªÉ x·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p:
        - 1 t·ª´ th√†nh 2 t·ª´
        - 2 t·ª´ th√†nh 1 t·ª´  
        - T·ª´ b·ªã thi·∫øu
        - T·ª´ th·ª´a
        """
        matches = []
        
        # T·∫°o ma tr·∫≠n similarity
        similarity_matrix = []
        for i, orig_word in enumerate(original_words):
            row = []
            for j, spoken_word in enumerate(spoken_words):
                # So s√°nh c·∫£ text v√† IPA
                text_sim = self._calculate_word_similarity(orig_word, spoken_word)
                ipa_sim = self._calculate_ipa_similarity(
                    self._get_ipa_pronunciation(orig_word),
                    self._get_ipa_pronunciation(spoken_word)
                )
                combined_sim = (text_sim + ipa_sim) / 2
                row.append(combined_sim)
            similarity_matrix.append(row)
        
        # T√¨m best matches s·ª≠ d·ª•ng dynamic programming approach
        used_spoken = set()
        used_original = set()
        
        # T√¨m matches v·ªõi threshold cao tr∆∞·ªõc
        high_threshold = 0.7
        for i in range(len(original_words)):
            if i in used_original:
                continue
            best_j = -1
            best_score = 0
            
            for j in range(len(spoken_words)):
                if j in used_spoken:
                    continue
                if similarity_matrix[i][j] > best_score and similarity_matrix[i][j] >= high_threshold:
                    best_score = similarity_matrix[i][j]
                    best_j = j
            
            if best_j != -1:
                matches.append((i, best_j, best_score))
                used_original.add(i)
                used_spoken.add(best_j)
        
        # X·ª≠ l√Ω cases ph·ª©c t·∫°p: 1 t·ª´ g·ªëc match v·ªõi nhi·ªÅu t·ª´ spoken
        for i in range(len(original_words)):
            if i in used_original:
                continue
            
            # Th·ª≠ combine 2-3 t·ª´ spoken li√™n ti·∫øp
            for window_size in [2, 3]:
                for j in range(len(spoken_words) - window_size + 1):
                    if any(k in used_spoken for k in range(j, j + window_size)):
                        continue
                    
                    combined_spoken = ''.join(spoken_words[j:j+window_size])
                    combined_sim = self._calculate_word_similarity(original_words[i], combined_spoken)
                    
                    if combined_sim >= 0.6:
                        matches.append((i, j, combined_sim))
                        used_original.add(i)
                        for k in range(j, j + window_size):
                            used_spoken.add(k)
                        break
                else:
                    continue
                break
        
        # X·ª≠ l√Ω remaining v·ªõi threshold th·∫•p h∆°n
        low_threshold = 0.4
        for i in range(len(original_words)):
            if i in used_original:
                continue
            best_j = -1
            best_score = 0
            
            for j in range(len(spoken_words)):
                if j in used_spoken:
                    continue
                if similarity_matrix[i][j] > best_score and similarity_matrix[i][j] >= low_threshold:
                    best_score = similarity_matrix[i][j]
                    best_j = j
            
            if best_j != -1:
                matches.append((i, best_j, best_score))
                used_original.add(i)
                used_spoken.add(best_j)
        
        return sorted(matches, key=lambda x: x[0])
    
    def _identify_word_errors(self, original_words: List[str], spoken_words: List[str]) -> List[WordError]:
        """X√°c ƒë·ªãnh c√°c t·ª´ b·ªã ph√°t √¢m sai"""
        errors = []
        matches = self._advanced_word_matching(original_words, spoken_words)
        
        matched_original_indices = {match[0] for match in matches}
        
        for i, original_word in enumerate(original_words):
            if i not in matched_original_indices:
                # T·ª´ b·ªã thi·∫øu ho√†n to√†n
                expected_ipa = self._get_ipa_pronunciation(original_word)
                errors.append(WordError(
                    word=original_word,
                    expected_ipa=expected_ipa,
                    actual_ipa="[missing]",
                    error_type="missing",
                    ipa_differences=[f"missing entire word '{expected_ipa}'"]
                ))
                continue
            
            # T√¨m match t∆∞∆°ng ·ª©ng
            match = next(match for match in matches if match[0] == i)
            _, spoken_idx, similarity = match
            
            if similarity < 0.8:  # Threshold cho t·ª´ sai
                spoken_word = spoken_words[spoken_idx] if spoken_idx < len(spoken_words) else "[missing]"
                expected_ipa = self._get_ipa_pronunciation(original_word)
                actual_ipa = self._get_ipa_pronunciation(spoken_word) if spoken_word != "[missing]" else "[missing]"
                
                ipa_diffs = self._find_ipa_differences(expected_ipa, actual_ipa)
                
                error_type = "mispronounced"
                if similarity < 0.4:
                    error_type = "severely_mispronounced"
                
                errors.append(WordError(
                    word=original_word,
                    expected_ipa=expected_ipa,
                    actual_ipa=actual_ipa,
                    error_type=error_type,
                    ipa_differences=ipa_diffs
                ))
        
        return errors
    
    def assess_pronunciation(self, original_text: str, spoken_text: str) -> str:
        """
        H√†m ch√≠nh ƒë·ªÉ ƒë√°nh gi√° ph√°t √¢m
        
        Args:
            original_text: C√¢u/t·ª´ g·ªëc
            spoken_text: K·∫øt qu·∫£ t·ª´ Speech-to-Text
            
        Returns:
            str: K·∫øt qu·∫£ ƒë√°nh gi√° v·ªõi c√¢u ƒë∆∞·ª£c ƒë√°nh d·∫•u v√† chi ti·∫øt l·ªói
        """
        # L√†m s·∫°ch v√† t√°ch t·ª´
        original_clean = self._clean_text(original_text)
        spoken_clean = self._clean_text(spoken_text)
        
        original_words = original_clean.split()
        spoken_words = spoken_clean.split()
        
        # T√¨m l·ªói
        self.word_errors = self._identify_word_errors(original_words, spoken_words)
        
        # T·∫°o c√¢u ƒë∆∞·ª£c ƒë√°nh d·∫•u
        marked_sentence = self._create_marked_sentence(original_text)
        
        # T·∫°o b√°o c√°o chi ti·∫øt
        result = [marked_sentence]
        result.append("")  # D√≤ng tr·ªëng
        
        if not self.word_errors:
            result.append("‚úÖ Ph√°t √¢m ch√≠nh x√°c!")
            return "\n".join(result)
        
        result.append("‚ùå C√°c l·ªói ph√°t √¢m ƒë∆∞·ª£c ph√°t hi·ªán:")
        result.append("")
        
        for error in self.word_errors:
            result.append(f"üî∏ T·ª´ '{error.word}':")
            result.append(f"   Expected IPA: {error.expected_ipa}")
            result.append(f"   Actual IPA:   {error.actual_ipa}")
            result.append(f"   Error type:   {error.error_type}")
            if error.ipa_differences:
                result.append(f"   IPA differences: {', '.join(error.ipa_differences)}")
            result.append("")
        
        return "\n".join(result)
    
    def _create_marked_sentence(self, original_text: str) -> str:
        """T·∫°o c√¢u ƒë∆∞·ª£c ƒë√°nh d·∫•u v·ªõi t·ª´ sai"""
        words = original_text.split()
        error_words = {error.word.lower() for error in self.word_errors}
        
        marked_words = []
        for word in words:
            clean_word = re.sub(r'[^\w]', '', word.lower())
            if clean_word in error_words:
                marked_words.append(f"**{word}**")
            else:
                marked_words.append(word)
        
        return " ".join(marked_words)


def assess_pronunciation(original_text: str, spoken_text: str) -> str:
    """
    H√†m wrapper ƒë·ªÉ d·ªÖ import v√† s·ª≠ d·ª•ng
    
    Args:
        original_text: C√¢u/t·ª´ g·ªëc
        spoken_text: K·∫øt qu·∫£ t·ª´ Speech-to-Text
        
    Returns:
        str: K·∫øt qu·∫£ ƒë√°nh gi√° chi ti·∫øt
    """
    assessor = PronunciationAssessment()
    return assessor.assess_pronunciation(original_text, spoken_text)


def main():
    """Ch∆∞∆°ng tr√¨nh ch√≠nh ƒë·ªÉ test"""
    print("=== Pronunciation Assessment Tool ===")
    print()
    
    # Test cases
    test_cases = [
        ("I would like a cup of coffee, please.", "I wood like a cup of coffe please"),
        ("The weather is beautiful today.", "The wether is butiful today"),
        ("She sells seashells by the seashore.", "She sells seeshells by the seeshore"),
        ("Hello world", "Hello word"),
        ("Good morning", "Good morening"),
    ]
    
    for i, (original, spoken) in enumerate(test_cases, 1):
        print(f"Test {i}:")
        print(f"Original: {original}")
        print(f"Spoken:   {spoken}")
        print()
        
        result = assess_pronunciation(original, spoken)
        print(result)
        print("="*60)
        print()
    
    # Interactive mode
    while True:
        print("\nüé§ Interactive Mode (press Enter twice to exit)")
        original = input("Enter original text: ").strip()
        if not original:
            break
            
        spoken = input("Enter spoken text (from Speech-to-Text): ").strip()
        if not spoken:
            break
            
        print("\n" + "="*50)
        result = assess_pronunciation(original, spoken)
        print(result)
        print("="*50)


if __name__ == "__main__":
    main()